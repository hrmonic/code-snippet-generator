{
  "id": "javascript-promise",
  "name": "Promises & Async/Await",
  "description": "Gestion des Promises avec async/await et utilitaires",
  "language": "javascript",
  "feature": "promise",
  "code": "// Promise de base\nfunction fetchData(url) {\n    return new Promise((resolve, reject) => {\n        fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                return response.json();\n            })\n            .then(data => resolve(data))\n            .catch(error => reject(error));\n    });\n}\n\n// Async/Await\nasync function fetchUserData(userId) {\n    try {\n        const user = await fetchData(`/api/users/${userId}`);\n        const posts = await fetchData(`/api/users/${userId}/posts`);\n        return { user, posts };\n    } catch (error) {\n        console.error('Error fetching user data:', error);\n        throw error;\n    }\n}\n\n// Promise.all - Exécution parallèle\nasync function fetchMultipleUsers(userIds) {\n    try {\n        const promises = userIds.map(id => fetchData(`/api/users/${id}`));\n        const users = await Promise.all(promises);\n        return users;\n    } catch (error) {\n        console.error('Error fetching users:', error);\n        throw error;\n    }\n}\n\n// Promise.allSettled - Toutes les promesses, même en cas d'erreur\nasync function fetchWithAllSettled(urls) {\n    const promises = urls.map(url => fetchData(url));\n    const results = await Promise.allSettled(promises);\n    \n    const successful = results\n        .filter(result => result.status === 'fulfilled')\n        .map(result => result.value);\n    \n    const failed = results\n        .filter(result => result.status === 'rejected')\n        .map(result => result.reason);\n    \n    return { successful, failed };\n}\n\n// Promise.race - Première promesse résolue\nasync function fetchWithTimeout(url, timeout = 5000) {\n    const fetchPromise = fetchData(url);\n    const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Timeout')), timeout)\n    );\n    \n    return Promise.race([fetchPromise, timeoutPromise]);\n}\n\n// Retry avec Promise\nasync function fetchWithRetry(url, maxRetries = 3, delay = 1000) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await fetchData(url);\n        } catch (error) {\n            if (i === maxRetries - 1) throw error;\n            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n        }\n    }\n}\n\n// Promise avec timeout personnalisé\nfunction createTimeoutPromise(ms) {\n    return new Promise((_, reject) => \n        setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)\n    );\n}\n\n// Utilisation\nasync function example() {\n    // Simple async/await\n    const user = await fetchUserData(1);\n    console.log(user);\n    \n    // Parallèle\n    const users = await fetchMultipleUsers([1, 2, 3]);\n    console.log(users);\n    \n    // Avec timeout\n    try {\n        const data = await fetchWithTimeout('/api/data', 3000);\n        console.log(data);\n    } catch (error) {\n        console.error('Request timed out');\n    }\n    \n    // Avec retry\n    try {\n        const data = await fetchWithRetry('/api/data', 3, 1000);\n        console.log(data);\n    } catch (error) {\n        console.error('Failed after retries');\n    }\n}",
  "variables": [],
  "security": {
    "sqlInjection": false,
    "xss": false
  }
}

